<div class="container py-4">
    <% if @hike_path&.errors&.any? %>
        <div class="alert alert-danger">
            <h2 class="h6"><%= pluralize(@hike_path&.errors&.count, "erreur") %> :</h2>
            <ul class="mb-0">
                <% @hike_path&.errors&.full_messages.each do |message| %>
                    <li><%= message %></li>
                <% end %>
            </ul>
        </div>
    <% end %>
    <div class="card rounded mt-3">
        <div class="card-header">
            <div class="d-flex justify-content-around text-center">
                <div>
                    <p class="mb-1"><strong>Distance :</strong></p>
                    <p id="distance">0 km</p>
                </div>
                <div>
                    <p class="mb-1"><strong>Dénivelé + :</strong></p>
                    <p id="elevation-gain">0 m</p>
                </div>
                <div>
                    <p class="mb-1"><strong>Dénivelé - :</strong></p>
                    <p id="elevation-loss">0 m</p>
                </div>
                <div>
                    <p class="mb-1"><strong>Altitude min :</strong></p>
                    <p id="min-altitude">0 m</p>
                </div>
                <div>
                    <p class="mb-1"><strong>Altitude max :</strong></p>
                    <p id="max-altitude">0 m</p>
                </div>
            </div>
        </div>
        <div class="card-body">
            <div class="mb-2">
                <button id="undo" class="btn btn-outline-dark" style="float: right">Supprimer le dernier point</button>
                <%= button_to "Sauvegarder le tracé",
                              hike_paths_path,
                              method: :post,
                              params: { points: @points, hike_id: @hike&.id },
                              class: "btn btn-outline-success" %>
                <div class="form-check mt-2">
                    <input class="form-check-input" type="checkbox" id="closeLoopCheckbox"/>
                    <label class="form-check-label" for="closeLoopCheckbox">Activer la fermeture de la boucle</label>
                </div>
            </div>
            <div id="map-container">
                <div id="map"></div>
            </div>
            <canvas id="elevationChart" width="800" height="200" style="display: none"></canvas>
        </div>
    </div>

</div>

<style>
    #map-container {
        position: relative;
        height: 30rem;
    }

    #map {
        height: 100%;
        width: 100%;
        position: relative;
    }

    .custom-div-icon {
        background: none;
        border: none;
    }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
<script type="module">
    const map = L.map('map').setView([44.0556, 5.1283], 13);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    const points = []; // Tableau pour stocker les points
    let markers = [];  // Tableau pour stocker les marqueurs
    let currentRoute;

    const apiKey = '5b3ce3597851110001cf6248d56a72cc718348038c651734f42f7749';

    const saveButton = document.querySelector('form[action="/hike_paths"]');
    const pointsInput = document.createElement('input');
    pointsInput.type = 'hidden';
    pointsInput.name = 'points';
    saveButton.appendChild(pointsInput);
    <% unless @hike_path&.coordinates.blank? %>
    let existingPoints = JSON.parse(<%= @hike_path.coordinates.to_json.html_safe %>);
    if (Array.isArray(existingPoints)) {
        existingPoints.forEach(point => {
            addPoint(point[0], point[1], `Point ${points.length + 1}`);
        });
    }
    <% end %>

    async function getRoute(points) {
        if (points.length < 2) {
            console.error('Au moins deux points sont nécessaires pour calculer un itinéraire.');
            return;
        }

        const url = `https://api.openrouteservice.org/v2/directions/foot-hiking/geojson?api_key=${apiKey}`;
        const coordinates = points.map(point => [point[1], point[0]]);

        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    coordinates,
                    elevation: true // Demande des données d'altitude
                })
            });
            const data = await response.json();

            console.log("Réponse API OpenRouteService:", data); // Log des données brutes renvoyées

            if (!data.features || data.features.length === 0) {
                console.error('Aucune route trouvée dans la réponse :', data);
                return;
            }

            if (currentRoute) {
                map.removeLayer(currentRoute);
            }

            currentRoute = L.geoJSON(data, {
                style: {color: 'blue', weight: 4}
            }).addTo(map);

            const bounds = currentRoute.getBounds();
            map.fitBounds(bounds);

            // Calcul et affichage des statistiques
            displayRouteStats(data);
        } catch (error) {
            console.error('Erreur lors de la requête API:', error);
        }
    }

    function displayRouteStats(data) {
        try {
            // Extraction des coordonnées et des altitudes
            const coordinates = data.features[0].geometry.coordinates;
            const altitudes = coordinates.map(coord => coord[2]); // Altitudes

            // Extraction des propriétés de l'itinéraire
            const summary = data.features[0].properties.summary;
            const properties = data.features[0].properties.segments[0];

            // Calcul de la distance
            const distance = summary.distance; // Distance en mètres
            document.getElementById('distance').textContent = (distance / 1000).toFixed(2) + ' km';

            // Calcul des dénivelés à partir des altitudes
            let elevationGain = 0;
            let elevationLoss = 0;

            for (let i = 1; i < altitudes.length; i++) {
                const diff = altitudes[i] - altitudes[i - 1];
                if (diff > 0) {
                    elevationGain += diff;
                } else {
                    elevationLoss -= diff;
                }
            }

            document.getElementById('elevation-gain').textContent = Math.round(elevationGain) + ' m';
            document.getElementById('elevation-loss').textContent = Math.round(elevationLoss) + ' m';

            // Calcul des altitudes minimale et maximale
            if (altitudes.length > 0) {
                const minAltitude = Math.min(...altitudes);
                const maxAltitude = Math.max(...altitudes);
                document.getElementById('min-altitude').textContent = Math.round(minAltitude) + ' m';
                document.getElementById('max-altitude').textContent = Math.round(maxAltitude) + ' m';
            } else {
                console.warn("Altitudes non trouvées dans les données.");
                document.getElementById('min-altitude').textContent = "Non disponible";
                document.getElementById('max-altitude').textContent = "Non disponible";
            }

            // Appeler la fonction pour générer le graphique de profil d'altitude
            generateElevationChart(coordinates);
        } catch (error) {
            console.error("Erreur lors du traitement des statistiques :", error);
        }
    }


    function addPoint(lat, lng, label) {
        const point = [lat, lng];
        points.push(point);
        pointsInput.value = JSON.stringify(points);
        const marker = L.marker([lat, lng], {title: label}).addTo(map);
        markers.push(marker);

        // Vérifie si trois points sont ajoutés pour fermer la boucle (si activée)
        const closeLoop = document.getElementById('closeLoopCheckbox').checked;
        if (points.length === 3 && closeLoop) {
            addClosingPoint();
        }

        if (points.length >= 2) {
            getRoute(points);
        }
    }

    function addClosingPoint() {
        if (points.length < 3) return;

        const firstPoint = points[0];
        points.push(firstPoint); // Ajoute le premier point à la fin du tableau
        const marker = L.marker(firstPoint, {
            title: "Point de départ (fermeture de la boucle)"
        }).addTo(map);
        markers.push(marker);

        getRoute(points); // Met à jour la route avec le point de fermeture
    }

    function removeLastPoint() {
        if (points.length === 0) return;

        points.pop();
        const marker = markers.pop();
        map.removeLayer(marker);

        if (points.length >= 2) {
            getRoute(points);
        } else if (currentRoute) {
            map.removeLayer(currentRoute);
        }
    }

    map.on('click', function (e) {
        const {lat, lng} = e.latlng;
        addPoint(lat, lng, `Point ${points.length + 1}`);
    });

    document.getElementById('undo').addEventListener('click', () => {
        removeLastPoint();
    });

    function calculateDistancesAndAltitudes(coordinates) {
        const distances = [0]; // Distance cumulée
        const altitudes = coordinates.map(coord => coord[2]); // Altitudes

        for (let i = 1; i < coordinates.length; i++) {
            const [lon1, lat1] = coordinates[i - 1];
            const [lon2, lat2] = coordinates[i];
            const distance = haversineDistance(lat1, lon1, lat2, lon2);
            distances.push(distances[i - 1] + distance);
        }

        return {distances, altitudes};
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Rayon de la Terre en km
        const toRad = x => (x * Math.PI) / 180;

        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);

        const a =
            Math.sin(dLat / 2) ** 2 +
            Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c; // Distance en km
    }

    function generateElevationChart(coordinates) {
        const {distances, altitudes} = calculateDistancesAndAltitudes(coordinates);

        // Crée un canvas pour le graphique
        let elevationChart = document.getElementById('elevationChart');
        const ctx = elevationChart.getContext('2d');
        elevationChart.style.display = "block";
        // Vérifie si le graphique existe et peut être détruit
        if (window.elevationChart && typeof window.elevationChart.destroy === 'function') {
            window.elevationChart.destroy();
        }

        // Crée un dégradé pour le graphique
        const gradient = ctx.createLinearGradient(0, 0, 0, 400);
        gradient.addColorStop(0, "rgba(255, 0, 0, 0.7)"); // Rouge (montée forte)
        gradient.addColorStop(0.5, "rgba(255, 255, 0, 0.7)"); // Jaune (plat)
        gradient.addColorStop(1, "rgba(0, 255, 0, 0.7)"); // Vert (descente)

        // Créer le graphique avec Chart.js
        window.elevationChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: distances.map(d => `${d.toFixed(2)} km`), // Distances en abscisses
                datasets: [
                    {
                        label: 'Altitude (m)',
                        data: altitudes,
                        borderColor: 'rgb(255,255,255)',
                        backgroundColor: gradient,
                        borderWidth: 2,
                        tension: 0.4,
                        pointStyle: false,
                        fill: true, // Ajoute un remplissage sous la ligne
                    },
                ],
            },
            options: {
                responsive: true,
                plugins: {
                    tooltip: {
                        intersect: false, // Permet l'affichage même si la souris n'est pas sur un point précis
                        mode: 'nearest', // Affiche le point le plus proche
                        callbacks: {
                            label: function (context) {
                                const altitude = context.raw;
                                const distance = distances[context.dataIndex];
                                return `Distance: ${distance.toFixed(2)} km, Altitude: ${altitude} m`;
                            },
                        },
                    },
                    legend: {
                        display: false, // Supprimer la légende
                    },
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Distance (km)',
                            font: {
                                size: 14,
                            },
                        },
                        grid: {
                            display: false, // Supprimer la grille verticale
                        },
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Altitude (m)',
                            font: {
                                size: 14,
                            },
                        },
                        grid: {
                            color: 'rgba(200, 200, 200, 0.5)', // Grille légère
                        },
                    },
                },
            },
        });
    }
</script>
